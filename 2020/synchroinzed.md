synchronized 修饰范围：

>静态方法  获取当前对象的锁（锁定这个类的 Class 对象，所有实例对象均 copy 自这个大的 Class 对象）

>实例方法  获取当前对象的锁

>代码块     获取某个对象锁



对象内存结构：

>非数组对象 用 instanceOopDesc 类描述

>数组对象 用arrayOopDesc 类描述

>非数组对象和数组对象 均继承 oopDesc 类

>oopDesc:

>>对象头 (_mark)(MarkWorld)：

>>>age_bits 分代年龄

>>>lock_bits 锁标识

>>>biased_lock_bits 是否为偏向锁

>>数据区域 _metadata：

>>>储存（类的源信息 对应的指针）

>对其填充



对象头在特定锁中 32 位空间分配

>无锁状态: 25位 存储对象的hashCode 4位 存储分代年龄 1位记录是否为偏向锁值为0  2位 存储所标志位值为01  

>偏向锁：23位 存储线程id 2位存储朝代（朝代指每一个线程在无竞争的情况下获取锁，则朝代加1） 4位 存储分代年龄 1位记录是否为偏向锁值为1  2位 存储所标志位值为01  

>轻量级锁：30位 存储栈中锁记录的指针  2位 存储所标志位值为00  

>重量级锁：30位 存储重量级锁的指针  2位 存储所标志位值为10

>gc标记：30位 null    2位 存储所标志位值为11



对象锁：

>公共条件：

>>加了synchronized 关键字之后，多个线程调用时，对象分为:

>偏向锁：

>>条件：

>>>可偏向状态: 将线程id case 到 markWorld 中如果成功 则当前锁为偏向锁

>>>已偏向状态：判断对象的存储的线程id与当前线程id 是否相等，如果相等，则锁为偏向锁

>>保持偏向锁过程：

>>>cas 成功，或者线程id与对象头线程id相等 即可不必升级为轻量级锁。 

>偏向锁->轻量级锁：

>>升级条件：

>>>可偏向状态:偏向锁 可偏向状态 如果 cas 失败 则将锁升级为轻量级锁

>>>已偏向状态：偏向锁 已偏向状态 如果不相等 则将锁升级为轻量级锁

>>升级过程：

>>>如果满足升级条件其中一条：

>>>>首先会暂停以获得偏向锁的线程

>>>>然后将对象头的线程 id 设置为空

>>>>恢复线程

>>>>线程在自己的栈帧中创建 LockRecord 锁记录对象

>>>>将对象头（markWorld）信息复制到 LockRecord 锁记录对象中

>>>>将线程 LockRecord 锁记录对象中的 Owner 属性赋值为 当前锁的对象

>>>>将当前锁对象的对象头（markWorld） 赋值为线程锁记录 LockRecord 对象

>轻量级锁：

>>自旋锁：

>>>线程在获取锁失败后会进入一个 for 循环等待一段时间（时间长短根据上一次执行时间来决定），然后再去获取锁。如果获得锁成功，则保持偏向锁不变。>

>>过程：

>>>满足上述条件以后，通过 cas 把线程锁记录LockRecord对象，替换回 对象头markWorld中，

>>>>将对象头（markWorld）信息复制到 LockRecord 锁记录对象中

>>>>将线程 LockRecord 锁记录对象中的 Owner 属性赋值为 当前锁的对象

>>>>将当前锁对象的对象头（markWorld） 赋值为线程锁记录 LockRecord 对象

>轻量级锁->重量级锁：

>>条件：

>>>轻量级锁的自旋锁，如果等待一段时间再次获得锁失败则升级为重量级锁。

>>升级过程：

>>>满足上述条件以后：

>>>>对象锁膨胀成重量级锁，后续竞争线程只能挂起。线程竞争锁时，回得到一个 monitor（监视器） 对象，

>>>>monitor.enter成功，则执行代码，

>>>>失败则 阻塞到同步队列中

>>>>获得锁的线程执行完成以后通知队列，

>>>>然后下一个线程继续执行对应逻辑



wait/notify/notifyAll:

>手动阻塞线程，由 wait 阻塞的线程只能通过 notify 或 notifyAll 唤醒：

>执行过程：

>>一个线程争抢锁时，首先获取一个 monitor 对象:

>>>onitor.enter 成功 :

>>>> 执行逻辑代码：

>>>> >执行到 wait 方法时：

>>>> >> 将当前线程加入到 阻塞队列中，并释放锁。

>>>> >执行到 notify\notifyAll时，唤醒阻塞在 这个对象锁的阻塞队列中 的某个\全部线程，这时某个\全部线程 将加入到挂起队列中，将线程挂起，然后通过cpu调度。

>>>onitor.enter 失败 : 将当前线程加入到挂起线程中，线程挂起，由cpu 决定什么时候调度

